# 알고리즘

## 4. 스택

### (1) 스택의 응용

후입선출



스택의 마지막 삽입 원소의 위치를 top이라 함

top : 비어있는 경우 -1, push 시 +1, pop -1

삽임 : push

삭제 : pop (삽입한 자료의 역순으로 꺼낸다.)

공백인지 아닌지 확인 : isEmpty

 값이 뭐있는지만 보기 : peek



append 연산은 복사 후 다시 넣는 것이므로 느리다.

collection의 dq를 사용해야 속도가 향상됨.



### (2) 스택의 응용

함수 호출 시 stack의 동작과 같이 가장 최근에 호출된 함수가 가장 먼저 return하고, main이 제일 마지막에 가서 종류하게 된다.



### (3) 알고리즘 패러다임

* 결정의 문제 (T, F 문제)

* 최적화 문제 (값을 구하라)

  * 그리디 알고리즘

    현재 상태에서 최적이라고 생각되는 값을 선택 후, 남은 것에 대한 최적을 선택

    속도는 빠르나, 모두 해결하진 못함

  * 동적 계획법

    주어진 문제를 모두 확인해보고, 작은 부분부터 단계별로 취합 후 최종해결

    속도는 빠르지 못하나, 모두 해결가능

### (4) 그래프

아이템과 이들 사이의 연결 관계를 표현

Vertex : 정점(요소)

Edge : 간선, 정점과 정점의 연결

V 개의 정점일 때 간선은 최대 (V(V-1))/2 

* 그래프의 유형에 대한 요소

  방향

  가중치

  cyle (시작한 정점에서 끝나는 경로)

  인접(두 개의 정점에 간선이 존재하면 정점간의 인접하다고 함)

  경로(간선들을 순서대로 나열한 것)

* 그래프 유형

  * 완전 그래프

    정점들에 대해 가능한 모든 간선들을 가진 그래프

  * 부분 그래프

    원래 그래프에서 일부의 정점이나 간선을 제외한 그래프

* 그래프의 표현

  * 인접행렬

    2차원 배열로 하여 행 번호, 열번호를 그래프의 정점에 대응

    방향성이 없다면 인접하면 1, 아니면 0으로 간선 정보를 저장

    대각선을 기준으로 대칭

    방향성이 있다면, 열이 가르치는 행에다가 1

    행의 합은 나가는 갯수 / 열의 합은 들어오는 갯수

    단점 : 메모리를 많이 차지

  * 인접 리스트

    각 정점마다 해당 정점과 연결된 정점만 저장

    메모리를 덜 차지

    단점 : 구현이 복잡

  * 간선의 배열

    간선에 대한 정보만 저장[시작 정점, 끝 정점]

### (5) DFS

깊이 우선 탐색 - 한 인접한 곳에서 안쪽으로 계속 들어가보고 가장 깊은 곳까지 가면 다시 원래 위치로 나와서 다음 정점을 탐색

방문하지 않은 정점이 있다면 나를 stack에 넣고 (되돌아가려고), 방문했다는 표시하고, push하면서 앞으로 가기

방문 안한 곳이 없다면 pop하면서 뒤로 이동

너비 우선 탐색 - 인접 정점을 확인하고, 그 다음에 안으로 넘어감