# 알고리즘

## 3. 문자열

### (1) 문자의 표현

문자인지 숫자인지 구별하는 방법 -> 실행코드가 읽어야할 영역에 정보를 갖고 있음

표준안 ASCII 코드 1byte 7bit 128문자 표현

대부분의 컴퓨터는  ASCII형식을 사용

그러나, 한글로는 표현하기 어려움 따라서,  2byte 사용  => 유니코드

그러나, 바이트 순서나 character set이 제대로 표준화되지 않았음



* big-endian, little-endian

  대부분은 큰 byte가 앞에 저장되고, 작은 byte가 뒤에 저장됨

* 유니코드 인코딩

  * UTF-8

    웹, 파이썬

  * UTF-16

    자바, 윈도우

  * UTF-32

    유닉스

* 문자열은 가변적인지 고정적인지
  * C언어 : 문자들의 배열 문자열 끝이 표현되는 경우(delimited)

    ​			' 문자한개', "문자열", '\0' 으로 문자열을 반드시 끝내주기

  * Java : 문자열의 class가 따로 있음

    ​		참조정보를 갖고 저장이 됨

    ​		문자열 String class 선언해주지 않아도 됨

  * python : chr 타입이 따로 없음

    ​				텍스트 데이터의 취급방법이 동일

    ​				문자열의 class가 따로 있음

    ​				인덱스, 슬라이싱이 가능 but 값 변경 불가능 (replace 만 예외)

### (2) 패턴매칭

* 고지식한 패턴 검색 알고리즘

  본문 문자열을 처음부터 끝까지 차례로 순회하며 패턴 내의 문자들을 일일이 비교하는 방식

  시간복잡도가 높음

* 카프-라빈 알고리즘

  수치화 알고리즘

  문자를 0-9사이 10진수의 숫자로 가정하고, 문자에 그 수를 넣어 패턴의 문자 수만큼의 진수로 만들고, 합을 계산함

  본문에서도 문자 수만큼 합을 계산하고, 이동을 해가면서 확인함

  합이 같으면 순차검색

  데이터 범위가 크지 않거나 패턴에 사용하는 문자가 몇 개 없으면 사용하기 유용함

  그러나, 10진수라는 한계가 있으며 값이 같으면 다시 순차검색을 해야한다는 한계가 있음

* KMP 알고리즘

  반복되는 문자가 있을 때 fail이 난 부분에서 다시 반복되는 부분부터 다시 비교시작 (매칭에 실패했을 때 돌아갈 곳을 준비해두는 형식으로 중복된 부분이 있다면 거기로 이동)

  패턴 문자에 중복이 많이 되는 경우에 매우 유용함

  그러나, 구현이 간단하지 않고, 미리 어디로 이동할지를 계산해야하여 그 계산이 어려워 시간이 오래걸릴 수 있고, 중복이 없다면 고지식과 같이 시간복잡도가 높음

* 보이어-무어 알고리즘

  가장 많이 사용되는 알고리즘

  뒤에서 부터 비교하는 알고리즘

  어떤 문자에 대하여 이 문자가 패턴 내부에 있는 지 확인하고, 있다면 같은 것이 있는 위치에 패턴을 이동시킴

  문자가 패턴 내부에 없으면 패턴 길이만큼 jump

  최악의 경우에도 M*N, 일반적으로 N보다 시간이 덜 듬

  

