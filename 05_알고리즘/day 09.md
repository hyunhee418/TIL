# 알고리즘

## 8. 트리

### 1. Intro

비선형 구조(1: 다 관계)

원소들 간의 계층구조를 가짐 (관계도나 계층도에 사용됨)

보통은 중심에서 내려가는 구조

루트 - 그 밑의 자식노드 또한 트리가 될 수 있음(서브트리)

단발노드 - 아래에 자식이 더 없음

노드의 차수 - 자식 노드 수

트리의 차수 - 트리에 있는 노드의 차수 중 가장 큰 값

레벨, 높이 - 얼마나



### 2. 이진트리

이진트리 - 2개의 서브트리를 갖는 형태의 트리

leff child node  /  right child node

높이 h인 이진 트리가 가질 수 있는 노드의 최소 개수 (h+1)개, 최대 개수 (2**(h+1) -1)



* 포화 이진 트리

  모든 레벨에 노드가 포화인 이진 트리

  노드 개수 : (2**(h+1) -1)

  1부터  (2**(h+1) -1)까지 노드 번호를 가짐



* 완전 이진 트리

  포화 이진 트리에서 뒷부분에 포화되기 전에 끊기는 경우



* 편향 이진 트리

  한 쪽 방향으로만 자식 노드를 가진 이진 트리



#### (1) 순회

부모에서 자식을 찾아가는 순서

부모를 언제 찾아가냐에 따라 순회 결정

* 전위 순회 - 부모 먼저 방문

```python
def preorder_traverse(T):
    if T:  # 말단 노드냐
        visit(T)
        preorder_traverse(T.left)
        preorder_traverse(T.right)
```



* 중위 순회 - 왼쪽 부모 오른쪽

```python
def inorder_traverse(T):
	if T:
        inorder_traverse(T.left)
        visit(T)
        inorder_traverse(T.right)
```



* 후위 순회 - 왼쪽 오른쪽 부모 

```python
def postorder_traverse(T):
	if T:
        postorder_traverse(T.left)
        postorder_traverse(T.right)
        visit(T)
```



#### (2) 배열

* 완전 이진 트리

  노드 번호가 i인 노드의 왼쪽 자식 : 2*i

  노드 번호가 i인 노드의 오른쪽 자식 : 2*i + 1

  레벨 n의 노드 번호 시작번호 : 2**n

* 편향 이진 트리

  사용하지 않는 배열 원소에 대한 메모리 공간 낭비 발생

중간에 새로운 노드 삽입하거나 기존 노드를 삭제할 경우 배열의 크기 변경 어려워 비효율적

따라서 링크드 리스트로 이러한 점 보완

A 노드에 left, right 값을 갖고가면서 2차원 배열로 짤 수 있다. (탐색 시)



#### (3) 수식트리

부모노드에는 연산자, 자식노드에 숫자가 들어간 트리



#### (4) 이진탐색트리

key(왼쪽 서브트리)<key(루트 노드)<key(오른쪽 서브트리)

중위순회하면 오름차순배열을 얻을 수 있다.

이진탐색트리인 경우, 삭제 삽입 연산할 때 재정렬하지 않아도 된다.



삭제연산 - 단말 노드일 때는 그냥 삭제

자식 노드가 1개일 때는 자식노드를 삭제노드자리로 대체

자식 노드가 2개일 때는 왼쪽 자식의 가장 오른쪽 끝과 오른 쪽 자식의 가장 왼쪽 끝 둘 중에 하나를 끌어다가 위로 올려주기