# 알고리즘

## 큐

삽입, 삭제 위치가 제한적인 자료구조

삽입 연산은 뒤로만 되고, 삭제는 앞에서만 일어나는 자료형태 (선입선출의 구조, 줄서기와 비슷)

머리(Front) - 삭제가 일어남 마지막 지워진 자리값 -> deQueue

꼬리(Rear) - 삽입이 일어남 원소가 있는 마지막 위치값 -> enQueue

createQueue() - list나 linked list등 자료구조 선택하여 공백의 큐를 생성

isEmpty() - 큐가 공백인지 확인 -> front와 rear 값이 같으면 공백

isFull() - 큐가 전부 차있는지 확인 -> len() -1이랑 rear와 같다면 전부 차있음

Qpeek() -front에 뭐가 있는지만 확인

### 선형큐

1차원 배열을 이용한 큐

- 큐의 크기 = 배열의 크기
- front : 저장된 첫 번째 원소의 인덱스
- rear : 저장된 마지막 원소의 인덱스

### 원형큐

메모리 낭비를 없애고 효율을 높이고자 원형으로 변경

rear = (rear + 1) % len(Q)

front는 항상 비워짐

따라서, full일 때 front == (rear+1) % 4

delete -> 삭제만 하고 return 되지는 않는다.

### 연결큐

이태까지의 큐는 같은 주소에 나란히 연속하여 저장되었다면, 연결큐는 각각 원소를 다른 주소에 저장하고 연결함으로써 더 효율적으로 값 사용 가능

주소값을 각각 갖고있으므로 front와 rear는 첫 번째 노드를 가르키는 주소, 마지막 노드를 가르키는 주소가 됨

크기 제한없이 무제한으로 붙일 수 있으며, delete하면 메모리가 날아감으로써 그 메모리자리가 비워짐

따라서 메모리를 효율적으로 쓰고 프로그램 성능을 높일 수 있음

### 우선순위 큐

우선순위가 높은 순서대로 먼저 나감

큐의 구조와 동일하지만 deQueue에서 우선순위 높은 것이 삭제됨

우선순위에 대한 정보를 따로 갖고 있어, 이를 삽입하면서 우선순위를 반영하는 경우도 있으며, 삭제하면서 반영하는 경우도 있다.

배열을 사용할 경우 원소 재배치가 발생함

따라서 불필요한 경우가 많이 발생함 -> 힙이나 트리를 이용하여 구현함

### 버퍼

데이터를 한 곳에서 다른 곳으로 전송하는 동안 일시적으로 그 데이터를 보관하는 영역

CPU에 비해 입출력, 네트워크 디바이스 속도 등이 느리기 때문에 일시적으로 버퍼에 저장했다가 CPU에서 한번에 처리한다.

표준입력장치 -> 키보드

표준출력장치 -> 모니터

