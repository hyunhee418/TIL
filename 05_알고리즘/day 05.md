# 알고리즘

## 5. 스택 2

### (1) 계산기

* infix / postfix notation

operator가 어디있냐의 차이

중위표기법 : A+B

후위표기법 : AB+

컴퓨터는 후위표기법으로 읽는다.

순차적으로 표현

토큰 : 의미있는 문자
숫자이면 출력
연산자이면 stack에 넣는다.

### (2) 백트래킹

재귀호출의 구조를 따라감

DFS는 모든 경로를 다 가보지만, 백트래킹은 불필요한 경로를 조기에 차단한다. (유효성 검사를 진행한다)

가장 짧은 길을 찾는 경우

prunig : 유망성을 체크하여 유망하지 않다면 가지 않음

k 깊이

input은 전체 집합의 원소의 개수



 부분집합 순열

k = 0인 상태에서 호출하면

k+= 1이 되어 k= 1

이 되고 원소1을 넣어주고,

다음 단계에서 원소1이 True가 되고 2, 3 이 candidate가 됨



### (3) 분할 정복 알고리즘

나눠서 일을 시키고 결과를 통합하는 것이 정확도와 효율에서 좋다



* 퀵정렬

  피봇을 기준으로 앞에는 작은 숫자, 뒤에는 큰 숫자가 오도록 한다.(피봇의 자리는 고정된다.)

  피봇 앞에 또다른 피봇을 만들어 작은 값, 큰 값을 나눈다.

  있는 메모리 사용

  최악의 경우 n제곱

  메모리 문제가 있다던가 주어진 크기가 크지 않을 때 많이 쓰임

  linked list를 쓴다고 효과가 좋아지진 않음

  

* 병합정렬

  다 나눈 후 올린다.

  통합의 과정이 필요

  extra 메모리가 필요

  속도가 더 빠름

  최악의 경우에도 nlogn만큼 나옴

  기존 정렬 위치가 보정되면서 정렬됨 (정렬의 안정성)

  더 많이 쓰는 추세

  linked list를 효율이 더 높고 안정성이 높다

  

* 팀소트 알고리즘

  하이브리드 병합정렬

  병합정렬에서 n의 개수가 클 때